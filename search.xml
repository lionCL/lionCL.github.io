<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flex布局使用中一些问题]]></title>
    <url>%2F2019%2F08%2F06%2Fflex%2F</url>
    <content type="text"><![CDATA[flex布局中使用遇到的一些问题 一、flex弹性盒模型对于某个元素只要声明了display: flex;，那么这个元素就成为了弹性容器，具有flex弹性布局的特性。 每个弹性容器都有两根轴：主轴和交叉轴，两轴之间成90度关系。注意：水平的不一定就是主轴。 每根轴都有起点和终点，这对于元素的对齐非常重要。 弹性容器中的所有子元素称为&lt;弹性元素&gt;，弹性元素永远沿主轴排列。 弹性元素也可以通过display:flex设置为另一个弹性容器，形成嵌套关系。因此一个元素既可以是弹性容器也可以是弹性元素。 弹性容器的两根轴非常重要，所有属性都是作用于轴的。下面从轴入手，将所有flex布局属性串起来理解 二、主轴flex布局是一种一维布局模型，一次只能处理一个维度（一行或者一列）上的元素布局，作为对比的是二维布局CSS Grid Layout，可以同时处理行和列上的布局。 也就是说，flex布局大部分的属性都是作用于主轴的，在交叉轴上很多时候只能被动地变化。 1. 主轴的方向我们可以在弹性容器上通过flex-direction修改主轴的方向。如果主轴方向修改了，那么： 交叉轴就会相应地旋转90度。 弹性元素的排列方式也会发生改变，因为弹性元素永远沿主轴排列。 2. 沿主轴的排列处理弹性元素永远沿主轴排列，那么如果主轴排不下，该如何处理？ 通过设置flex-wrap: nowrap | wrap | wrap-reverse可使得主轴上的元素不折行、折行、反向折行。 默认是nowrap不折行，难道任由元素直接溢出容器吗？当然不会，那么这里就涉及到元素的弹性伸缩应对，下面会讲到。 wrap折行，顾名思义就是另起一行，那么折行之后行与行之间的间距（对齐）怎样调整？这里又涉及到交叉轴上的多行对齐。 wrap-reverse反向折行，是从容器底部开始的折行，但每行元素之间的排列仍保留正向。 3. 一个复合属性1flex-flow = flex-drection + flex-wrap flex-flow相当于规定了flex布局的“工作流(flow)” 1flex-flow: row nowrap; 三、元素如何弹性伸缩应对当flex-wrap: nowrap;不折行时，容器宽度有剩余/不够分，弹性元素们该怎么“弹性”地伸缩应对？ 这里针对上面两种场景，引入两个属性(需应用在弹性元素上) flex-shrink：缩小比例（容器宽度&lt;元素总宽度时如何收缩） flex-grow：放大比例（容器宽度&gt;元素总宽度时如何伸展） 1. flex-shrink: 缩小比例来看下以下场景，弹性容器#container宽度是200px，一共有三个弹性元素，宽度分别是50px、100px、120px。在不折行的情况下，此时容器宽度是明显不够分配的。 实际上，flex-shrink默认为1，也就是当不够分配时，元素都将等比例缩小，占满整个宽度，如下图。 1234#container &#123; display: flex; flex-wrap: nowrap;&#125; 元素收缩的计算方法真的是等比缩小(每个元素各减去70/3的宽度)吗？这里稍微深究一下它的收缩计算方法。 弹性元素1：50px→37.03px 弹性元素2：100px→74.08px 弹性元素3：120px→88.89px 先抛结论：flex-shrink: 1并非严格等比缩小，它还会考虑弹性元素本身的大小。 容器剩余宽度：-70px 缩小因子的分母：1*50 + 1*100 + 1*120 = 270 (1为各元素flex-shrink的值) 元素1的缩小因子：1*50/270 元素1的缩小宽度为缩小因子乘于容器剩余宽度：1*50/270 * (-70) 元素1最后则缩小为：50px + (1*50/270 *(-70)) = 37.03px 加入弹性元素本身大小作为计算方法的考虑因素，主要是为了避免将一些本身宽度较小的元素在收缩之后宽度变为0的情况出现。 2. flex-grow: 放大比例同样，弹性容器#container宽度是200px，但此时只有两个弹性元素，宽度分别是50px、100px。此时容器宽度是有剩余的。 那么剩余的宽度该怎样分配？而flex-grow则决定了要不要分配以及各个分配多少。 （1）在flex布局中，容器剩余宽度默认是不进行分配的，也就是所有弹性元素的flex-grow都为0。 （2）通过指定flex-grow为大于零的值，实现容器剩余宽度的分配比例设置。 元素放大的计算方法放大的计算方法并没有与缩小一样，将元素大小纳入考虑。 仅仅按flex-grow声明的份数算出每个需分配多少，叠加到原来的尺寸上。 容器剩余宽度：50px 分成每份：50px / (3+2) = 10px 元素1放大为：50px + 3 * 10 = 80px 无多余宽度时，flex-grow无效下图中，弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效 同理，对于flex-shrink，在容器宽度有剩余时也是不会生效的。因此这两个属性是针对两种不同场景的互斥属性。 四、弹性处理与刚性尺寸在进行弹性处理之余，其实有些场景我们更希望元素尺寸固定，不需要进行弹性调整。设置元素尺寸除了width和height以外，flex还提供了一个flex-basis属性。 flex-basis设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在flex-grow和flex-shrink生效前的尺寸。 1. 与width/height的区别首先以width为例进行比较。看下下面的例子。#container {display:flex;}。 1234&lt;div id="container"&gt; &lt;div&gt;11111&lt;/div&gt; &lt;div&gt;22222&lt;/div&gt;&lt;/div&gt; (1) 两者都为0 width: 0 —— 完全没显示 flex-basis: 0 —— 根据内容撑开宽度 (2) 两者非0 width: 非0; flex-basis: 非0 —— 数值相同时两者等效 —— 同时设置，flex-basis优先级高 (3) flex-basis为auto flex-basis为auto时，如设置了width则元素尺寸由width决定；没有设置则由内容决定 (4) flex-basis == 主轴上的尺寸 != width 将主轴方向改为：上→下 此时主轴上的尺寸是元素的height flex-basis == height 2. 常用的复合属性 flexflex = flex-grow + flex-shrink + flex-basis 复合属性，前面说的三个属性的简写。 一些简写 flex: 1 = flex: 1 1 0% flex: 2 = flex: 2 1 0% flex: auto = flex: 1 1 auto; flex: none = flex: 0 0 auto; // 常用于固定尺寸 不伸缩 flex:1 和 flex:auto 的区别其实可以归结于flex-basis:0和flex-basis:auto的区别。 flex-basis是指定初始尺寸，当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸；相反当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。因此从下图（转自W3C）可以看到绝对弹性元素如果flex-grow值是一样的话，那么他们的尺寸一定是一样的。 五、容器内如何对齐前面讲完了元素大小关系之后，下面是另外一个重要议题——如何对齐。可以发现上面的所有属性都是围绕主轴进行设置的，但在对齐方面则不得不加入作用于交叉轴上。需要注意的是这些对齐属性都是作用于容器上。 1. 主轴上的对齐方式justify-content 2. 交叉轴上的对齐方式主轴上比较好理解，重点是交叉轴上。因为交叉轴上存在单行和多行两种情况。 交叉轴上的单行对齐align-items 默认值是stretch，当元素没有设置具体尺寸时会将容器在交叉轴方向撑满。 当align-items不为stretch时，此时除了对齐方式会改变之外，元素在交叉轴方向上的尺寸将由内容或自身尺寸（宽高）决定。 交叉轴上的多行对齐还记得可以通过flex-wrap: wrap使得元素在一行放不下时进行换行。在这种场景下就会在交叉轴上出现多行，多行情况下，flex布局提供了align-content属性设置对齐。 align-content与align-items比较类似，同时也比较容易迷糊。下面会将两者对比着来看它们的异同。 首先明确一点：align-content只对多行元素有效，会以多行作为整体进行对齐，容器必须开启换行。 123align-content: stretch | flex-start | flex-end | center | space-between | space-aroundalign-items: stretch | flex-start | flex-end | center | baseline 在属性值上，align-content比align-items多了两个值：space-between和space-around。 align-content与align-items异同对比与align-items一样，align-content:默认值也是stretch。两者同时都为stretch时，毫无悬念所有元素都是撑满交叉轴。 1234#container &#123; align-items: stretch; align-content: stretch;&#125; 当我们将align-items改为flex-start或者给弹性元素设置一个具体高度，此时效果是行与行之间形成了间距。 123456789101112#container &#123; align-items: flex-start; align-content: stretch;&#125;/*或者*/#container &#123; align-content: stretch;&#125;#container &gt; div &#123; height: 30px;&#125; 为什么？因为align-content会以整行为单位，此时会将整行进行拉伸占满交叉轴；而align-items设置了高度或者顶对齐，在不能用高度进行拉伸的情况下，选择了用间距。 尝试把align-content设置为顶对齐，此时以行为单位，整体高度通过内容撑开。 而align-items仅仅管一行，因此在只有第一个元素设置了高度的情况下，第一行的其他元素遵循align-items: stretch也被拉伸到了50px。而第二行则保持高度不变。 1234567#container &#123; align-items: stretch; align-content: flex-start;&#125;#container &gt; div:first-child &#123; height: 50px;&#125; 这里仅对第二个元素的高度进行设置，其他元素高度则仍保持内容撑开。 以第一个图为例，会发现align-content会将所有行进行顶对齐，然后第一行由于第二个元素设置了较高的高度，因此体现出了底对齐。 两者差异总结： 两者“作用域”不同 align-content管全局(所有行视为整体) align-items管单行 能否更灵活地设置交叉轴对齐除了在容器上设置交叉轴对齐，还可以通过align-self单独对某个元素设置交叉轴对齐方式。 值与align-items相同 可覆盖容器的align-items属性 默认值为auto，表示继承父元素的align-items属性 12345678910111213141516#container &#123; display: flex; align-items: flex-start;&#125;#container &gt; div:first-child &#123; align-self: stretch;&#125;#container &gt; div:nth-child(3) &#123; align-self: center;&#125;#container &gt; div:nth-child(4) &#123; align-self: flex-end;&#125; 六、其他order：更优雅地调整元素顺序 123456789101112#container &gt; div:first-child &#123; order: 2;&#125;#container &gt; div:nth-child(2) &#123; order: 4;&#125;#container &gt; div:nth-child(3) &#123; order: 1;&#125;#container &gt; div:nth-child(4) &#123; order: 3;&#125; order：可设置元素之间的排列顺序 数值越小，越靠前，默认为0 值相同时，以dom中元素排列为准 七、总结 [^1]: &lt;感谢大佬的解析 原地址:https://www.cnblogs.com/qcloud1001/p/9848619.html&gt;]]></content>
      <categories>
        <category>flex</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs笔记总结]]></title>
    <url>%2F2019%2F08%2F01%2Fnodejs%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[nodejs的一些笔记心得 1.终端常用命令 md 创建目录 rmdir(rd) 删除目录，目录内没有文档。 echo on a.txt 创建空文件 del 删除文件 rm 文件名 删除文件 cat 文件名 查看文件内容 cat &gt; 文件名 向文件中写上内容。 2.nvm常用的命令 nvm list 查看当前安装的Node.js所有版本 nvm install 版本号 安装指定版本的Node.js nvm uninstall 版本号 卸载指定版本的Node.js nvm use 版本号 选择指定版本的Node.js 2.什么是nodejs 1.Node 是一个构建于 Chrome V8引擎之上的一个Javascript运行环境 Node是一个运行环境，作用是让js拥有开发服务端的功能 2.Node使用事件驱动、非阻塞IO模型（异步读写）使得它非常的轻量级和高效 Node中绝大多数API都是异步（类似于ajax），目的是提高性能 3.Node中的NPM是世界上最大的开源库生态系统（类似于github） NMP官网:https://www.npmjs.com 3.服务端js与客户端js区别 1.客户端JS由三部分组成 ECMAScript：确定js的语法规范 DOM：js操作网页内容 BOM：js操作浏览器窗口 2.服务端JS只有ECMAScript 因为服务端是没有界面的 ==在nodejs中使用dom与bom的api程序会报错== 4.ES6语法新特性变量声明let与const let声明的变量不存在预解析 let声明的变量不允许重复（在同一个作用域内） 块内部定义的变量，在外部是不可以访问的 for循环括号中声明的变量只能在循环体中使用 在块级作用域内部，变量只能先声明再使用 const用来声明常量 const声明的常量不允许重新赋值 const声明的常量必须初始化 变量的解构赋值 数组解构赋值 12345// 数组的解构赋值// let [a,b,c] = [1,2,3];// let [a,b,c] = [,123,];// let [a=111,b,c] = [,123,];// console.log(a,b,c); 对象解构赋值 1234567// 对象的解构赋值// let &#123;foo,bar&#125; = &#123;foo : 'hello',bar : 'hi'&#125;;// let &#123;foo,bar&#125; = &#123;bar : 'hi',foo : 'hello'&#125;;// 对象属性别名(如果有了别名，那么原来的名字就无效了)// let &#123;foo:abc,bar&#125; = &#123;bar : 'hi',foo : 'nihao'&#125;;// console.log(foo,bar 字符串解构赋值 123456789// 字符串的解构赋值// let [a,b,c,d,e,length] = "hello";// console.log(a,b,c,d,e);// console.log(length);// console.log("hello".length);// let &#123;length&#125; = "hi";// console.log(length); 字符串扩展 includes() 判断字符串中是否包含指定的字串（有的话返回true，否则返回false）\ 参数一：匹配的字串 参数二：从第几个开始匹配 startsWith() 判断字符串是否以特定的字串开始 endsWith() 判断字符串是否以特定的字串结束 模板字符串 12345// console.log('hello world'.includes('world',7));// let url = 'admin/index.php';// console.log(url.startsWith('aadmin'));// console.log(url.endsWith('phph')); 函数扩展 参数默认值 参数结构赋值 1234// function foo(&#123;uname='lisi',age=13&#125;=&#123;&#125;)&#123;// console.log(uname,age);// &#125;// foo(&#123;uname:'zhangsan',age:15&#125;); rest参数 1234567// rest参数（剩余参数）// function foo(a,b,...param)&#123;// console.log(a);// console.log(b);// console.log(param);// &#125;// foo(1,2,3,4,5); 扩展运算符 12345678910111213// 扩展运算符 ...function foo(a,b,c,d,e,f,g)&#123; console.log(a + b + c + d + e + f + g);&#125;// foo(1,2,3,4,5);let arr = [1,2,3,4,5,6,7];// foo.apply(null,arr);foo(...arr);// 合并数组let arr1 = [1,2,3];let arr2 = [4,5,6];let arr3 = [...arr1,...arr2];console.log(arr3); 箭头函数 /* 无参无返回函数 */ ES6: 将function关键字使用 =&gt; 符号代替 12345678910111213141516//注意点：形参小括号写在 箭头前面，无参时不能省略let fn1 = ()=&gt;&#123; console.log('开工大吉');&#125;;//注意点：形参小括号写在 箭头前面，无参时不能省略// function foo()&#123;// console.log('hello');// &#125;// foo();// let foo = () =&gt; console.log('hello');// foo();//如果函数体只有一行，可以省掉大括号fn1 = ()=&gt; console.log('开工大吉');fn1(); 注意事项: 1、多个参数必须用小括号包住 2、箭头函数中this取决于函数的定义，而不是调用 3、箭头函数不可以new 4、箭头函数不可以使用arguments获取参数列表，可以使用rest参数代替 类与继承 5.Node模块化在Node.js中没有window对象,没有DOM,BOM，但是有一个类似的对象global，访问全局成员的时候可以省略global Node js特点 1.模块化开发 模块化相关的规则： ​ 1、如何定义模块：一个js文件就是一个模块，模块内部的成员都是相互独立(避免了命名冲突) ​ 2、模块成员的导出和引入 如果要导出单个的成员或者比较少的成员，一般我们使用exports导出； ​ 如果要导出的成员比较多，一般我们使用module.exports的方式 ​ 这两种方式不能同时使用 1234567891011var sum = function(a,b)&#123; return parseInt(a) + parseInt(b);&#125;// 导出模块成员exports.sum = sum;// 导出成员的另一种方式module.exports = function()&#123; console.log('hello');&#125;; 2.fs文件模块(读写文件) 在nodejs中如果想要进行文件操作,就必须引入 fs 这个核心模块 在fs这个核心模块中,就提供了所有的文件操作相关的API 通过读取到的文件其实都是二进制数据, 01 ,但是转化成了16进制 可以通过 toString方法转化为我们看得懂的字符串 1.1-readFile读取文件12345678910111213141516171819202122232425262728293031323334//1.导入文件模块const fs = require('fs');//2.读取文件fs.readFile('./data/aaa.txt','utf-8',(err,data)=&gt;&#123; * 第一个参数：文件路径 第二参数：文件编码 默认utf-8 * 第三参数：回调函数,接收两个参数 error ---- 如果读取失败 error就是错误对象 如果读取成功 error就是null data ----- 如果读取成功 data就是读取到的数据 如果读取失败error错误对象 //通过err判断是或有错误发生 if(err)&#123; console.log(读取失败) //抛出异常，throw的作用就是让node程序终止运行，方便调试 throw err; &#125;else&#123; console.log(读取成功 &#125;;&#125;);console.log('11111');//3.同步读取文件(了解即可，几乎不用,一般在异步的api后面加上Sync就是同步)let data = fs.readFileSync('./data/aaa.txt','utf-8');console.log(data);console.log('2222'); 1.2-writeFile写入文件1234567891011121314151617181920//1.导入文件模块const fs = require('fs');//2.写文件/** * 第一个参数：要写入的文件路径 * 第二个参数：要写入的内容/数据 * 第三个参数：文件编码 默认utf-8 * 第四个参数： 异步回调函数 * err: 如果成功，err为null. 如果失败就是错误对象 */fs.writeFile('./data/bbb.txt','黑马程序员','utf-8',(err)=&gt;&#123; if(error)&#123; console.log('写入失败'); &#125;else&#123; console.log('写入成功'); &#125;;&#125;); 6.同步与异步区别 同步会有阻塞线程,异步不会 同步有序执行,异步无序执行 同步没有回调函数,异步有 js从上解析代码流程 判断是同步还是异步 如果是同步则立即执行 如果是异步则不执行,而是放入事件玄幻中(Event Loop) 所有代码解析完毕之后,开始执行使劲循环中的异步代码 nodejs 异步执行的任务; 文件 I / o 网络 I / o 7.http模块(搭建服务器) 搭建一个服务器的目的是服务器可以提供对数据的鼓舞 可以通过使用createServer( ) 方法构建一个web服务器 步骤: 1.导入模块 要使用 HTTP 服务器和客户端，必须 require(‘http’) const http = require(‘http’); 2.创建服务器 使用createServer()方法构建一个web服务器,返回一个Server实例 参数：回调函数 ​ req:request 客户端请求的数据 ​ res:response 服务端响应的数据 3.启动服务器 1.1-http 模块搭建服务器1234567891011121314151617181920212223242526272829//1.导入模块const http = require('http');//2.创建服务器/*createServer 相当于安装了 phpStudy中的Apache 参数：回调函数 req:request 客户端请求的数据 res:response 服务端响应的数据 */let server = http.createServer((req,res)=&gt;&#123; //服务端每收到一个客户端请求都会执行一次该回调函数，这个函数会执行多次 //req.url:获取客户端请求的路径 console.log('客户端请求的数据' + req.url); &#125;);//3.启动服务器（相当于点击了phpStuty的开启按钮）/*第一个参数：端口号第二个参数：ip地址 默认不写，就是本机ip（127.0.0.1）第三个参数 */server.listen(3000,'127.0.0.1',(err)=&gt;&#123; console.log('服务器启动成功');&#125;); 1.2-响应客户端请求1234567891011121314151617//1.导入HTTP模块const http = require('http');//2.创建服务器let server = http.createServer((req,res)=&gt;&#123; //服务器每收到一次请求都会调用一次这个函数 //req:负责接收客户端请求 //res:负责响应客户端请求 /* 注意：服务器响应给客户端只能是两种数据类型： 一：文本 二：二进制 否则程序报错 */ res.end('hello world');&#125;);//3.开启服务器server.listen(3000,(err)=&gt;&#123; console.log('服务器开启成功'); &#125;); 1.3-根据不同请求响应不同数据1234567891011121314151617181920212223242526272829303132333435363738//1.导入HTTP模块const http = require('http');//2.创建服务器let server = http.createServer((req,res)=&gt;&#123; //服务器每收到一次请求都会调用一次这个函数 //req:负责接收客户端请求 //res:负责响应客户端请求 console.log(req.url);//获取到的内容是127.0.0.1：3000后面的内容，url路径通常以'/'开头 if(req.url == '/a')&#123; res.end('hello world'); &#125;else if(req.url == '/login')&#123;// //设置服务器响应头： 作用：服务端告诉客户端，我响应给你的数据是什么类型 res.writeHead(200,&#123; 'Content-Type':'text/plain;charset=utf8' //text/plain:普通文本 &#125;); res.end('这是登录页'); &#125;else if(req.url == '/')&#123; //如果本次没有请求路径（127.0.0.1：3000），通常表示首页 res.writeHead(200,&#123; 'Content-Type':'text/html;charset=utf8' //text/html文本 &#125;); res.end('&lt;h1&gt;这是首页&lt;/h1&gt;'); &#125;else&#123; //如果客户端请求了服务端无法识别的路径，一般响应404 res.end('404 not found'); &#125;;&#125;);//3.开启服务器server.listen(3000,()=&gt;&#123; console.log('服务器开启成功');&#125;) 1.4-http响应客户端HTML文件123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.导入http模块const http = require('http');const fs = require('fs');//2.创建服务器let server = http.createServer((req,res)=&gt;&#123; console.log(req.url); //一般情况下，如果返回的是文件二进制数据，浏览器会自动识别文件格式解析加载 if(req.url == '/')&#123;// 请求路径为/，返回首页 fs.readFile('./data/index.html',(err,data)=&gt;&#123; if(err)&#123; throw err; &#125;else&#123; console.log(data); res.end(data); &#125;; &#125;); &#125;else if(req.url == '/login.html')&#123; fs.readFile('./data/login.html',(err,data)=&gt;&#123; if(err)&#123; throw err; &#125;else&#123; res.end(data); &#125;; &#125;); &#125;else if(req.url == '/image.jpg')&#123; fs.readFile('./data/image.jpg',(err,data)=&gt;&#123; if(err)&#123; throw err; &#125;else&#123; res.end(data); &#125;; &#125;); &#125;else&#123; res.end('404 not found'); &#125;;&#125;);//3.开启服务器server.listen(3000,(err)=&gt;&#123; console.log('服务器启动成功');&#125;); 8.Nodejs路径 node中的相对路径： ./ 不是相对于当前文件所在路径，而是相对于执行node命名的文件夹路径 在服务端开发中，一般不要使用相对路径，而使用绝对路径 解决方案：在nodejs中，每一个js文件都有两个全局属性，它可以帮助我们获取到文件的绝对路径 __filename:当前js文件所在目录的绝对路径 __dirmame:当前js文件的绝对路径 console.log(dirname);console.log(filename); buffer对象buffer是一个缓冲区,主要用于操作二进制的数据流,用法跟数组非常的相识 1.创建一个buffer实例使用new操作符,有四种方法创建一个Buffer实例 new Buffer(size)，创建一个指定大小的buffer 12var buf = new Buffer(10);console.log(buf); //&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; new Buffer(array)，根据一个字节数组来创建一个buffer 12var bf=new Buffer([1,2,3]);console.log(bf); //&lt;Buffer 01 02 03&gt; new Buffer(str[,encoding])，根据一个字符串和编码格式创建buffer，不指定编码时默认使用utf8 12345var bf1=new Buffer(&apos;miao&apos;,&apos;utf-8&apos;);console.log(bf1);for(var i=0;i&lt;bf1.length;i++)&#123; console.log(String.fromCharCode(bf1[i]));&#125; new Buffer(buffer)，根据buffer实例创建一个新的buffer buf.write()方法1buf.write(string[, offset][, length][, encoding]) //往Buffer对象中写入数据 uf.write用来向缓冲区中写入一个字符串，返回实际写入的字节数。参数含义如下： string，待写入的字符串对象 offset，缓冲区偏移量，指定的话就从这个位置开始写入，不指定就默认为0 length，要写入的字节数 encoding，代谢如字符串的编码格式，默认为utf8 buf.toString()方法123456789buf.toString([encoding], [start], [end]) // 根据 encoding参数（默认是 &apos;utf8&apos;）返回一个解码的 string 类型var bf=new Buffer(&quot;xiaoxu&quot;);console.log(bf);console.log(bf.toString());var bf2=new Buffer(&quot;小徐&quot;);console.log(bf2);console.log(bf2.toString(&apos;utf-8&apos;,3)); 如果不知道开始位置，则将字符全部返回，如果指定了开始位置和结束位置则按指定的返回，在上面实例中，因为一个中文占3个字节，所以在bf2这个实例中，我们指定从第三个位置开始，则返回的是徐这个汉字 buf.toJSON()1//返回一个 JSON表示的Buffer实例。JSON.stringify将会默认调用来字符串序列化这个Buffer实例 buf.slice()方法buf.slice([start], [end]) ://返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，注意：修改这个新的buffer实例slice切片，也会改变原来的buffer]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇blog]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%AC%AC%E4%B8%80%E7%AF%87blog%2F</url>
    <content type="text"><![CDATA[lionCL第一篇文章]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
